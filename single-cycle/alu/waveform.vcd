$date
	Sat Nov  8 20:35:49 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb1 $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$var integer 32 # i [31:0] $end
$var integer 32 $ instr_count [31:0] $end
$scope module top_module_dut $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 64 % rs2 [63:0] $end
$var wire 64 & rs1 [63:0] $end
$var wire 64 ' pc_out [63:0] $end
$var wire 64 ( pc_in [63:0] $end
$var wire 64 ) operand1 [63:0] $end
$var wire 64 * mem_read_data [63:0] $end
$var wire 1 + is_jalr $end
$var wire 1 , is_jal $end
$var wire 1 - is_auipc $end
$var wire 32 . instruction [31:0] $end
$var wire 64 / imm [63:0] $end
$var wire 1 0 branch_taken_out $end
$var wire 1 1 branch $end
$var wire 1 2 alu_zero $end
$var wire 64 3 alu_out [63:0] $end
$var wire 1 4 RegWrite $end
$var wire 1 5 MemtoReg $end
$var wire 1 6 MemWrite $end
$var wire 2 7 MemWidth [1:0] $end
$var wire 1 8 MemSign $end
$var wire 1 9 MemRead $end
$var wire 5 : ALUCtrl [4:0] $end
$scope module alu_dut $end
$var wire 64 ; and_ans [63:0] $end
$var wire 64 < andi_ans [63:0] $end
$var wire 64 = or_ans [63:0] $end
$var wire 64 > ori_ans [63:0] $end
$var wire 64 ? xor_ans [63:0] $end
$var wire 64 @ xori_ans [63:0] $end
$var wire 1 A t2 $end
$var wire 1 B t1 $end
$var wire 1 C t0 $end
$var wire 64 D sub_ans [63:0] $end
$var wire 64 E srli_ans [63:0] $end
$var wire 64 F srl_ans [63:0] $end
$var wire 64 G srai_ans [63:0] $end
$var wire 64 H sra_ans [63:0] $end
$var wire 64 I sltui_ans [63:0] $end
$var wire 64 J sltu_ans [63:0] $end
$var wire 64 K slti_ans [63:0] $end
$var wire 64 L slt_ans [63:0] $end
$var wire 64 M slli_ans [63:0] $end
$var wire 64 N sll_ans [63:0] $end
$var wire 64 O rs2 [63:0] $end
$var wire 64 P rs1 [63:0] $end
$var wire 64 Q imm [63:0] $end
$var wire 1 2 alu_zero $end
$var wire 64 R addi_ans [63:0] $end
$var wire 64 S add_ans [63:0] $end
$var wire 5 T ALUCtrl [4:0] $end
$var parameter 32 U ALU_CTRL_BITS $end
$var parameter 32 V REG_WIDTH $end
$var reg 64 W alu_out [63:0] $end
$upscope $end
$scope module alu_op1_mux_dut $end
$var wire 1 X jump $end
$var wire 64 Y rs1 [63:0] $end
$var wire 64 Z pc [63:0] $end
$var wire 64 [ operand1 [63:0] $end
$var parameter 32 \ PC_WIDTH $end
$var parameter 32 ] REG_WIDTH $end
$upscope $end
$scope module branch_taken_dut $end
$var wire 3 ^ funct3 [2:0] $end
$var wire 64 _ rs2 [63:0] $end
$var wire 64 ` rs1 [63:0] $end
$var parameter 32 a REG_WIDTH $end
$var reg 1 0 branch_taken_out $end
$upscope $end
$scope module control_unit_dut $end
$var wire 1 9 MemRead $end
$var wire 1 6 MemWrite $end
$var wire 1 5 MemtoReg $end
$var wire 1 4 RegWrite $end
$var wire 1 1 branch $end
$var wire 1 b s_type $end
$var wire 1 c r_type $end
$var wire 7 d opcode [6:0] $end
$var wire 1 e load_type $end
$var wire 1 f is_lui $end
$var wire 1 + is_jalr $end
$var wire 1 , is_jal $end
$var wire 1 - is_auipc $end
$var wire 32 g instruction [31:0] $end
$var wire 1 h i_type $end
$var wire 7 i funct7 [6:0] $end
$var wire 6 j funct6 [5:0] $end
$var wire 3 k funct3 [2:0] $end
$var wire 1 l b_type $end
$var parameter 32 m ALU_CTRL_BITS $end
$var parameter 32 n REG_WIDTH $end
$var reg 5 o ALUCtrl [4:0] $end
$var reg 1 8 MemSign $end
$var reg 2 p MemWidth [1:0] $end
$upscope $end
$scope module data_mem_dut $end
$var wire 1 9 MemRead $end
$var wire 1 8 MemSign $end
$var wire 2 q MemWidth [1:0] $end
$var wire 1 6 MemWrite $end
$var wire 1 ! clk $end
$var wire 64 r full_addr [63:0] $end
$var wire 64 s wdata [63:0] $end
$var wire 10 t addr [9:0] $end
$var parameter 32 u ADDR_WIDTH $end
$var parameter 32 v MEM_DEPTH $end
$var parameter 32 w REG_WIDTH $end
$var reg 64 x rdata [63:0] $end
$upscope $end
$scope module imm_gen_dut $end
$var wire 7 y opcode [6:0] $end
$var wire 32 z instruction [31:0] $end
$var parameter 32 { REG_WIDTH $end
$var reg 64 | imm [63:0] $end
$upscope $end
$scope module instruction_mem_dut $end
$var wire 1 ! clk $end
$var wire 64 } pc [63:0] $end
$var parameter 32 ~ ADDR_WIDTH $end
$var parameter 32 !" PC_WIDTH $end
$var reg 32 "" instruction [31:0] $end
$upscope $end
$scope module pc_change_dut $end
$var wire 1 1 branch $end
$var wire 1 0 branch_taken $end
$var wire 64 #" imm [63:0] $end
$var wire 1 , is_jal $end
$var wire 1 + is_jalr $end
$var wire 1 $" temp1 $end
$var wire 1 %" temp0 $end
$var wire 64 &" rs1 [63:0] $end
$var wire 64 '" pc_branch [63:0] $end
$var wire 64 (" pc_4 [63:0] $end
$var wire 64 )" pc [63:0] $end
$var parameter 32 *" PC_WIDTH $end
$var parameter 32 +" REG_WIDTH $end
$var reg 64 ," pc_next [63:0] $end
$upscope $end
$scope module pc_reg_dut $end
$var wire 1 ! clk $end
$var wire 64 -" pc_in [63:0] $end
$var wire 1 " rst $end
$var parameter 32 ." PC_WIDTH $end
$var reg 64 /" pc_out [63:0] $end
$upscope $end
$scope module reg_file_dut $end
$var wire 1 ! clk $end
$var wire 5 0" raddr1 [4:0] $end
$var wire 5 1" raddr2 [4:0] $end
$var wire 1 " rst $end
$var wire 5 2" waddr [4:0] $end
$var wire 64 3" wdata [63:0] $end
$var wire 1 4 writeEnable $end
$var wire 64 4" rdata2 [63:0] $end
$var wire 64 5" rdata1 [63:0] $end
$var parameter 32 6" REG_COUNT $end
$var parameter 32 7" REG_WIDTH $end
$scope begin $unm_blk_7 $end
$var integer 32 8" i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope task print_regfile $end
$var integer 32 9" i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1000000 7"
b100000 6"
b1000000 ."
b1000000 +"
b1000000 *"
b1000000 !"
b1010 ~
b1000000 {
b1000000 w
b10000000000 v
b1010 u
b1000000 n
b101 m
b1000000 a
b1000000 ]
b1000000 \
b1000000 V
b101 U
$end
#0
$dumpvars
bx 9"
b100000 8"
b0 5"
b0 4"
b11101101100 3"
b111 2"
b1100 1"
b0 0"
b0 /"
b100 -"
b100 ,"
b0 )"
b100 ("
b11101101100 '"
b0 &"
0%"
0$"
b11101101100 #"
b1110110110000000000001110010011 ""
b0 }
b11101101100 |
b1110110110000000000001110010011 z
b10011 y
bx x
b1101101100 t
b0 s
b11101101100 r
b0 q
b0 p
b10000 o
0l
b0 k
b11101 j
b111011 i
1h
b1110110110000000000001110010011 g
0f
0e
b10011 d
0c
0b
b0 `
b0 _
b0 ^
b0 [
b0 Z
b0 Y
0X
b11101101100 W
b10000 T
b0 S
b11101101100 R
b11101101100 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b1 K
b0 J
b1 I
b0 H
b0 G
b0 F
b0 E
b0 D
0C
0B
0A
b11101101100 @
b0 ?
b11101101100 >
b0 =
b0 <
b0 ;
b10000 :
09
08
b0 7
06
05
14
b11101101100 3
12
01
10
b11101101100 /
b1110110110000000000001110010011 .
0-
0,
0+
bx *
b0 )
b100 (
b0 '
b0 &
b0 %
b10 $
bx #
1"
0!
$end
#5
b100000 8"
1!
#10
0!
b0 #
0"
#15
02
b100 D
b100 S
b100 =
b100 ?
b100 t
b1100100000000000100 3"
b100 G
b100 E
b100 M
b100 H
b100 F
b100 N
b100 )
b100 P
b100 [
b1100100000000000100 3
b1100100000000000100 W
b1100100000000000100 r
1X
00
b1 I
b1 K
b1100100000000000100 R
b1100100000000000100 >
b1100100000000000100 @
b1000 (
b1000 ,"
b1000 -"
b10111 y
b0 j
b0 i
b100 k
0h
1-
b10111 d
b100 ^
b0 1"
b1100 0"
b1100 2"
b1100100000000000000 /
b1100100000000000000 Q
b1100100000000000000 |
b1100100000000000000 #"
b1100100000000000100 '"
b1000 ("
b1100100011000010111 .
b1100100011000010111 g
b1100100011000010111 z
b1100100011000010111 ""
b100 '
b100 Z
b100 }
b100 )"
b100 /"
1!
#20
0!
b1 #
b100000 9"
#25
bx t
b0x J
b0x L
x2
xB
xC
bx ;
bx 3
bx W
bx r
bx 3"
x4
xX
bx %
bx O
bx _
bx s
bx 4"
0$"
b0x I
b0x K
xA
b1100 (
b1100 ,"
b1100 -"
bx R
bx D
bx S
bx >
bx @
bx =
bx ?
bx y
bx j
bx i
bx k
xc
xh
x5
x9
xe
x6
xb
x1
xl
x,
x+
xf
x-
bx d
bx ^
bx 1"
bx 0"
bx 2"
b0 /
b0 Q
b0 |
b0 #"
bx &
bx Y
bx `
bx &"
bx 5"
b1000 '"
b1100 ("
bx G
bx E
bx M
bx H
bx F
bx N
bx )
bx P
bx [
bx .
bx g
bx z
bx ""
b1000 '
b1000 Z
b1000 }
b1000 )"
b1000 /"
1!
#30
0!
b10 #
b100000 9"
